\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{graphicx}

\begin{document}

\title{Designing a Dynamic Kick for the Nao Robot}
\author{ Inge Becht \\ 
         Maarten de Jonge \\ 
         Richard Pronk \\\\
         \large{University of Amsterdam}}
\date{\today}
\maketitle

\section{Introduction} 
Our research is concerned with making a dynamic, closed
loop kick for the Nao robot. The Nao is a 58 cm tall humanoid robot made by Aldebaran Robots\footnote{http://www.aldebaran-robotics.com/en/}. It is used in the Stand Platform League of the Robocup\footnote{http://www.robocup.org/}, an organisation which organizes football (soccer) competitions for autonomous robots.

Kicking, of course, is an important part of football, and thus a good kick is vital to achieving good results in the Robocup. There are essentially two ways of making a humanoid robot kick a ball:
\begin{enumerate}
  \item Positioning the robot in a specific place relative to the ball, then executing a manually specified series of movements
  \item Using the location of the ball, and the angle you want the ball to go to dynamically determine a trajectory for the robot to move
\end{enumerate}
The first one is referred to as a \emph{keyframe motion}, while the second one is the subject of this paper.

\section{Motivation for this project} 
While the Dutch Nao Team (the team that represents the University of Amsterdam in the Standard Platform League of the Robocup) has achieved some degree of success with simple keyframe motions, they are clearly not optimal; a lot of time is wasted positioning the robot at just the right angle relative to kick the ball towards the goal. Furthermore, if the ball gets moved after the kicking motion has started, it's impossible for the robot to correct its kicking path. These are all problems that can be reduced with a dynamically generated motion, which is why we will attempt to create one. If we succeed in our endeavour, the resulting kick will be integrated in the Dutch Nao Team's codebase.

\subsection{Stability}
Since there is more than one player on
the field  chasing after the ball,
there is lots of interference from other Naos while kicking. Due to the
instability of the Nao this results in falling down quite often, even more
so when there is no compensation for it when executing a motion. A dynamic
kick keeps track of the stability and will execute a kick that keeps the nao
most stable.

Overheating is also a problem for Naos. When this occurs the joints will perform
not as expected or even fail. Using this dynamic system the temperature of the
joints can be used to prevent overheating. The executed kick will depend less
on force so the robot will spare its joints.

\subsection{Harder kicks and better stability}
Being able to define when a kick is stable enough to execute we can make a
trade-off between how far the ball is kicked and the stableness of the
robot, resulting in harder kicks then when using keyframe motions.

\subsection{Helping the Dutch Nao Team}
 Working on this project will help the Dutch Nao Team in their competition. The
current keyframe motion used by DNT is very brittle, with our dynamic kick we will create a
more robust kick that can give our universities team a bigger chance of
winning in competitions. 
This integration makes this project a valuable activity in the long run, and not
just a one time experiment.

\section{Methodology}
The task of kicking a ball requires a couple of things: We need to find a path
for the foot to travel, then we need a way to calculate the joint angles
corresponding to the required position of the foot (inverse kinematics), and all
the while we have to make sure the robot doesn't fall over.

\subsection{Automatic balancing during the kicking motion}
The Nao should be balanced during its kick, regardless of the motion of the
kicking leg. For this a center of mass-based approach is used along with a
proportional controller (\emph{cite wikipedia or something here}).

\subsubsection{Center of mass and support polygon}
This balancing approach requires knowledge of 2 concepts; the \emph{center of mass},
and the \emph{support polygon}. The center of mass (\emph{CoM}) is the weighted average
location of the Nao’s mass, while the support polygon is the location on the
floor over which the center of mass must be located to achieve stability. In the
case of a robot standing on the ground, the support polygon is the convex hull
of the feet touching the ground.

The center of mass is a bit more complex to calculate. It's defined as the sum
of each component’s \emph{centroid} (its own center of mass) multiplied by its
mass, divided by the total weight (equation \ref{eq:CoM}). This of course
requires each centroid to be described in the same coordinate system.
\begin{align}
  \frac{\sum_i \vec{c}_i m_i} {m}        \label{eq:CoM}
\end{align}
In the Nao’s documentation, each component’s centroid is described relative to
its own coordinate system, and offsets are included to convert between adjacent
components’ coordinate systems. To handle this, we construct a chain of
transformations to walk through each component while calculating the center of
mass of the entire robot.

\subsubsection{The proportional controller}
The goal of the proportional controller (\emph{P-controller}) is to keep the
CoM as close as possible to the center of the support polygon at all times.
The CoM is calculated relative to the standing leg's ankle joint, and we define
the center of the support polygon to be ``about 3cm in front of that''. Thus the
error-calculation becomes:
\begin{align}
	d &= \begin{bmatrix} 3 \\ 0 \end{bmatrix} - \vec{CoM_{xy}} \\
	error &= \sum_{i \in d} |i|
\end{align}
The Z-axis is ignored, because the height is irrelevant in this case (the CoM
balancer only accounts for gravity, not other phenomena such as momentum).

The proportional control equation with an arbitrary \emph{gain} parameter is
shown in equation \ref{eq:pcontrol}.
\begin{align}
	P_{out} = gain * error 				\label{eq:pcontrol}
\end{align}

Actuation is achieved solely through the hip's pitch and roll of the standing leg.
The rotation angles are obtained by searching through all combinations of the angles
$(0, P_{out}, -P_{out})$ for both joints (thus searching through a $3^3$ sized space)
and selecting the pair of angles with the largest reduction in error.

\subsection{The kinematics problem}
We want to be able to specify a location for the foot, then have the foot
automatically move there, which means that the we'll need to be able calculate
the required joint angles. This is known as \emph{inverse kinematics}. There are
two potential solutions to this problem:
\begin{enumerate}
  \item analytically solve the inverse kinematics chain using goniometry (as done by \cite{Graf2009})
\item use a hillclimbing algorithm to approach the desired location over a number of iterations
\end{enumerate}

We're currently leaning towards the second option, mainly because it’s easier,
more standard, and can deal with unreachable positions (it simply approaches the
closest reachable position).

\subsection{The kick}
With the solutions to the previous aspects of the dynamic kick constructed, 
we can start to calculate the optimal kicking trajectory. This kick is composed
of different stages, loosely based on the approach of \cite{Xu2010}.
\begin{itemize}
    \item Initial pose
    \item Retraction point
    \item Contact point
    \item fitting A bezier curve
\end{itemize}

\subsubsection(Initial pose)
The first stage is the initial pose. The nao is positions its center of mass on
top of its standing leg and lowers his center of mass so as to get a more stable
position. This stage is still
hardcoded using keyvalues as it makes for a smoother transition to the kicking
motion, without having to rely on the balance controllers. 

\subsubsection{Contact point }

\subsubsection(Retraction point)
After the initial pose the nao calculates its optimal retraction point. This
is the rearmost point from which the kick commences, and has two criteria that
should be satisfied:
\begin{itemize}
    \item The retraction point should be far away from the ball
    \item The retraction point should be accurate
\end{itemize}
To meet both criteria as good as possible there should be a trade off between
the two.

Firstly, to determine the point between the ball and a possible retraction point
we use the following calculation \cite{Xu2010}  : 

\begin{align*}
    d = ||\vec{pc_{xy}} - \vec{p_{xy}} || * 0.7 + ||\vec{_pc_z} -
    \vec{p_z} || * 0.3\\
\end{align*}

Where $\vec{pc}$ is the contact pointwhere the ball should be hit and
$\vec{p}$ is a possible retraction point and $\vec{d}$ the distance between both
points. The reason the ${xy}$ dimensions get more weight is because heightening
the feet for a bigger distance of the retraction is less desirable as it creates
more imbalance and takes up more time.


Finding the accuracy of a given retraction point resolves to finding 
will have the following
calculation is made:

\begin{align*}
\end{align*}

\section{Required materials and support} 
To find a solution to our problem statement we need a Nao to experiment on and a
possible simulation environment for at home. All of these materials are
available in the robolab.

Furthermore, there are different papers concerned with the problems we are
trying to tackle, but none of them cover the whole problem statement, and not
all are specifically about the Nao. For example we found a paper about
calculating the center of mass for robots with multiple joints\cite{Cotton2008} but not tailored
to the connection of joints of a  Nao robot.The difficulty for us is to put all this
information together and to make it work specifically on the Nao, and to
document this process at the same time. Most of the problems have been covered
in previous courses, but it still will require some insight in achieving our set
goals.


\bibliographystyle{plain}
\bibliography{library}
\end{document}
