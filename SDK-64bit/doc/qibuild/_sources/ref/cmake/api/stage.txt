.. Generated by /home/hudson/qi-1.12/qibuild/doc/tools/gen_cmake_doc.py
.. DO NOT EDIT

.. highlight:: cmake

Staging targets
================

This module make libraries and executables build in this projects available
to others projects.



qi_stage_lib
------------

.. cmake:function:: qi_stage_lib(target [DEPRECATED <deprecated> ...] [DEPENDS <depends> ...] [INCLUDE_DIRS <include_dirs> ...] [DEFINITIONS <definitions> ...] [PATH_SUFFIXES <path_suffixes> ...])

    :arg target: a target created with qi_create_lib
    :arg DEPRECATED: specify a deprecated message. This message will be displayed each time another project use that lib.
    :arg DEPENDS: if not given, ${TARGET}_DEPENDS will be guessed from the previous calls to qi_use_lib(). Use this (whith care!) to override this behavior.
    :arg INCLUDE_DIRS: it not given, ${TARGET}_INCLUDE_DIRS  will be guessed from the previous calls to include_directories() Use this (whith care!) to override this behavior.
    :arg DEFINITIONS: list of compilation flags targets depending of this library should use.
    :arg PATH_SUFFIXES: when your header is installed in foo/bar.h, but you still need to do #include <bar.h>, you can set PATH_SUFFIXES to 'foo'. Be careful to test the intall rules of your headers if you choose to do so.

    Generate a 'name'-config.cmake, allowing other project to find the library.



qi_stage_header_only_lib
------------------------

.. cmake:function:: qi_stage_header_only_lib(target [DEPRECATED <deprecated> ...] [DEPENDS <depends> ...] [INCLUDE_DIRS <include_dirs> ...] [DEFINITIONS <definitions> ...] [PATH_SUFFIXES <path_suffixes> ...])

    :arg target: a target created with qi_create_lib
    :arg DEPRECATED: specify a deprecated message. This message will be displayed each time another project use that lib.
    :arg DEPENDS: if not given, ${TARGET}_DEPENDS will be guessed from the previous calls to qi_use_lib(). Use this (whith care!) to override this behavior.
    :arg INCLUDE_DIRS: it not given, ${TARGET}_INCLUDE_DIRS  will be guessed from the previous calls to include_directories() Use this (whith care!) to override this behavior.
    :arg DEFINITIONS: list of compilation flags targets depending of this library should use.
    :arg PATH_SUFFIXES: when your header is installed in foo/bar.h, but you still need to do #include <bar.h>, you can set PATH_SUFFIXES to 'foo'. Be careful to test the intall rules of your headers if you choose to do so.

    Generate a 'name'-config.cmake, allowing other project to find the library.
    This library does not have to be a cmake target, it's a header only library.



qi_stage_bin
------------

.. cmake:function:: qi_stage_bin()


    not implemented yet



qi_stage_script
---------------

.. cmake:function:: qi_stage_script()


    not implemented yet



qi_stage_cmake
--------------

.. cmake:function:: qi_stage_cmake(module)

    :arg module: path to the module file, relative to CMAKE_CURRENT_SOURCE_DIR 

    stage a cmake file
    For instance, assuming you have a foo-config.cmake file
    containing my_awesome_function, you can do::
    
      qi_stage_cmake("foo-config.cmake")
    
    Then later, (in an other project, or in the same project)::
    
      find_package(foo)
      my_awesome_function()
    



qi_use_lib
----------

.. cmake:function:: qi_use_lib(name [<remaining args> ...])

    :arg name: The target to add dependencies to.
    :arg remaining args: dependencies  

    Handles dependencies between projects.
    
    Call find_package for you, then do all the include_directories
    and target_link_libraries that are needed.
    
    .. note:: The name must be an existing target, so you must call
        ``qi_use_lib`` **after** :cmake:function:`qi_create_bin` or :cmake:function:`qi_create_lib`
    
    You can however call ``qi_use_lib`` several times, for instance::
    
     qi_create_bin(foo)
    
     ...
    
     qi_use_lib(foo bar)
     if(UNIX)
        qi_use_lib(foo PTHREAD)
     endif()
    


